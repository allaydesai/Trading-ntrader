"""Integration tests for BacktestEngine with real Nautilus components.

These tests verify strategy behavior using the real Nautilus BacktestEngine
with minimal configuration and Nautilus TestStubs for test data.

Purpose: Test full strategy lifecycle with real framework components
Reference: design.md Section 3.1 and Appendix A.3
"""

import pytest
from decimal import Decimal
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import BacktestEngineConfig, LoggingConfig, CacheConfig
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.providers import TestInstrumentProvider
from nautilus_trader.test_kit.stubs.data import TestDataStubs
from nautilus_trader.test_kit.stubs.identifiers import TestIdStubs

from tests.fixtures import VOLATILE_MARKET, TRENDING_MARKET, RANGING_MARKET


@pytest.mark.integration
class TestBacktestEngineWithSMAStrategy:
    """Test SMA strategy with real Nautilus BacktestEngine."""

    def test_backtest_engine_initializes_with_minimal_config(self):
        """Test that BacktestEngine initializes with minimal configuration.

        Verifies the minimal configuration pattern from design.md:
        - Minimal logging (ERROR level to reduce noise)
        - Minimal cache config
        - Proper cleanup with dispose()
        """
        # Minimal BacktestEngine configuration
        config = BacktestEngineConfig(
            trader_id=TraderId("BACKTESTER-001"),
            logging=LoggingConfig(log_level="ERROR"),  # Suppress noisy logs
            cache=CacheConfig(tick_capacity=1000),  # Minimal cache
        )

        engine = BacktestEngine(config=config)

        # Verify engine initialized
        assert engine is not None
        assert engine.cache is not None

        # Cleanup
        engine.dispose()

    def test_backtest_engine_accepts_instrument_from_test_provider(self):
        """Test adding instruments using Nautilus TestInstrumentProvider.

        Following best practice: Use TestInstrumentProvider instead of
        manually creating instruments.
        """
        config = BacktestEngineConfig(
            trader_id=TraderId("BACKTESTER-001"),
            logging=LoggingConfig(log_level="ERROR"),
            cache=CacheConfig(tick_capacity=1000),
        )

        engine = BacktestEngine(config=config)

        # Use Nautilus test utilities (don't recreate the wheel)
        instrument = TestInstrumentProvider.btcusdt_binance()
        engine.add_instrument(instrument)

        # Verify instrument added
        assert instrument.id.symbol.value == "BTCUSDT"

        # Cleanup
        engine.dispose()

    @pytest.mark.parametrize(
        "scenario", [VOLATILE_MARKET], ids=lambda s: s.name if hasattr(s, "name") else str(s)
    )
    def test_sma_strategy_with_volatile_market(self, scenario):
        """Test SMA strategy with real Nautilus engine using volatile market scenario.

        This test demonstrates proper use of Nautilus test utilities:
        - TestInstrumentProvider for instruments
        - TestDataStubs for market data
        - Minimal BacktestEngineConfig

        Note: This is a simplified test that verifies the engine can process
        market data. Full strategy integration will be tested in
        test_strategy_execution.py.
        """
        # Minimal BacktestEngine configuration
        config = BacktestEngineConfig(
            trader_id=TraderId("BACKTESTER-001"),
            logging=LoggingConfig(log_level="ERROR"),
            cache=CacheConfig(tick_capacity=1000),
        )

        engine = BacktestEngine(config=config)

        # Use Nautilus test utilities
        instrument = TestInstrumentProvider.btcusdt_binance()
        engine.add_instrument(instrument)

        # Add test data from scenario using TestDataStubs
        bars = []
        for price in scenario.prices:
            bar = TestDataStubs.bar_5decimal(
                instrument_id=instrument.id, close=float(price)
            )
            bars.append(bar)

        engine.add_data(bars)

        # Verify data added to engine
        # Note: Full strategy behavior testing will be in test_strategy_execution.py
        assert len(bars) == len(scenario.prices)

        # Cleanup
        engine.dispose()

    def test_backtest_engine_with_trending_market(self):
        """Test BacktestEngine processes trending market data correctly.

        Trending markets should be favorable for SMA strategies.
        This test verifies the engine can handle steady uptrend data.
        """
        config = BacktestEngineConfig(
            trader_id=TraderId("BACKTESTER-001"),
            logging=LoggingConfig(log_level="ERROR"),
            cache=CacheConfig(tick_capacity=1000),
        )

        engine = BacktestEngine(config=config)

        # Use TestInstrumentProvider
        instrument = TestInstrumentProvider.ethusdt_binance()
        engine.add_instrument(instrument)

        # Add trending market data
        bars = []
        for price in TRENDING_MARKET.prices:
            bar = TestDataStubs.bar_5decimal(
                instrument_id=instrument.id, close=float(price)
            )
            bars.append(bar)

        engine.add_data(bars)

        # Verify trending data loaded
        assert len(bars) == len(TRENDING_MARKET.prices)
        assert TRENDING_MARKET.expected_pnl_positive is True  # Should be profitable

        # Cleanup
        engine.dispose()

    def test_backtest_engine_with_ranging_market(self):
        """Test BacktestEngine processes ranging market data correctly.

        Ranging markets typically produce losses for trend-following strategies.
        This test verifies the engine can handle sideways market data.
        """
        config = BacktestEngineConfig(
            trader_id=TraderId("BACKTESTER-001"),
            logging=LoggingConfig(log_level="ERROR"),
            cache=CacheConfig(tick_capacity=1000),
        )

        engine = BacktestEngine(config=config)

        # Use TestInstrumentProvider
        instrument = TestInstrumentProvider.default_fx_ccy("EUR/USD")
        engine.add_instrument(instrument)

        # Add ranging market data
        bars = []
        for price in RANGING_MARKET.prices:
            bar = TestDataStubs.bar_5decimal(
                instrument_id=instrument.id, close=float(price)
            )
            bars.append(bar)

        engine.add_data(bars)

        # Verify ranging data loaded
        assert len(bars) == len(RANGING_MARKET.prices)
        assert RANGING_MARKET.expected_pnl_positive is False  # Choppy = losses

        # Cleanup
        engine.dispose()

    def test_backtest_engine_cleanup_prevents_memory_leaks(self):
        """Test that engine.dispose() properly cleans up C extensions.

        This test verifies cleanup to prevent memory leaks from C extensions.
        See design.md Section 5.2 for cleanup patterns.
        """
        config = BacktestEngineConfig(
            trader_id=TraderId("BACKTESTER-001"),
            logging=LoggingConfig(log_level="ERROR"),
            cache=CacheConfig(tick_capacity=1000),
        )

        engine = BacktestEngine(config=config)

        # Add some data
        instrument = TestInstrumentProvider.btcusdt_binance()
        engine.add_instrument(instrument)

        bar = TestDataStubs.bar_5decimal(
            instrument_id=instrument.id, close=50000.0
        )
        engine.add_data([bar])

        # Explicit cleanup
        engine.dispose()

        # After dispose, engine should be in disposed state
        # Note: Specific assertions depend on Nautilus engine implementation
        # This test primarily documents the cleanup requirement
