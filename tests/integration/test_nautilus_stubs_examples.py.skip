"""Examples of using Nautilus TestStubs for integration testing.

This module demonstrates best practices for using Nautilus test utilities:
- TestInstrumentProvider for creating test instruments
- TestDataStubs for creating market data (bars, quotes, ticks)
- TestIdStubs for creating test identifiers
- TestEventStubs for creating test events

These examples follow patterns from the Nautilus testing documentation to
avoid reinventing the wheel and ensure compatibility with framework updates.

Purpose: Reference examples for proper Nautilus TestStubs usage
Reference: design.md Appendix A.4 - Using Nautilus TestStubs
"""

import pytest
from decimal import Decimal
from nautilus_trader.test_kit.providers import TestInstrumentProvider
from nautilus_trader.test_kit.stubs.data import TestDataStubs
from nautilus_trader.test_kit.stubs.identifiers import TestIdStubs
from nautilus_trader.test_kit.stubs.events import TestEventStubs


@pytest.mark.integration
class TestNautilusStubsUsage:
    """Examples of using Nautilus test utilities correctly.

    Following patterns from docs/testing/testing-philosophy-trading-engine.md
    """

    def test_using_test_instrument_provider(self):
        """Use TestInstrumentProvider instead of creating instruments manually.

        TestInstrumentProvider provides pre-configured instruments that match
        real exchange specifications. This is more reliable than manually
        creating instruments with potentially incorrect parameters.

        Available methods:
        - btcusdt_binance() - Bitcoin/USDT on Binance
        - ethusdt_binance() - Ethereum/USDT on Binance
        - default_fx_ccy(symbol) - Generic FX currency pair
        - Many more in Nautilus documentation
        """
        # ✅ Good: Use provided test instruments
        btc = TestInstrumentProvider.btcusdt_binance()
        eth = TestInstrumentProvider.ethusdt_binance()
        eur_usd = TestInstrumentProvider.default_fx_ccy("EUR/USD")

        # Verify instruments have expected properties
        assert btc.id.symbol.value == "BTCUSDT"
        assert eth.id.symbol.value == "ETHUSDT"
        assert eur_usd.id.symbol.value == "EUR/USD"

        # Instruments have realistic exchange properties
        assert btc.price_increment is not None
        assert btc.size_increment is not None

    def test_using_test_data_stubs_for_quotes(self):
        """Use TestDataStubs for creating quote tick data.

        Quote ticks represent bid/ask price updates. TestDataStubs provides
        convenient methods for creating realistic quote data.
        """
        # ✅ Good: Use TestDataStubs for quotes
        quote = TestDataStubs.quote_tick(
            instrument_id=TestIdStubs.btcusdt_binance_id(),
            bid_price=50000.0,
            ask_price=50001.0,
        )

        # Verify quote properties
        assert quote.instrument_id.symbol.value == "BTCUSDT"
        assert quote.bid_price.as_double() == 50000.0
        assert quote.ask_price.as_double() == 50001.0

    def test_using_test_data_stubs_for_bars(self):
        """Use TestDataStubs for creating bar (OHLCV) data.

        Bars represent aggregated price data over time periods.
        TestDataStubs.bar_5decimal() provides bars with 5 decimal precision.
        """
        # ✅ Good: Use TestDataStubs for bars
        bar = TestDataStubs.bar_5decimal(
            instrument_id=TestIdStubs.ethusdt_binance_id(),
            open=3000.0,
            high=3100.0,
            low=2950.0,
            close=3050.0,
        )

        # Verify bar properties
        assert bar.instrument_id.symbol.value == "ETHUSDT"
        assert bar.open.as_double() == 3000.0
        assert bar.high.as_double() == 3100.0
        assert bar.low.as_double() == 2950.0
        assert bar.close.as_double() == 3050.0

    def test_using_test_data_stubs_with_minimal_params(self):
        """Use TestDataStubs with minimal parameters for quick test data.

        When you only care about specific fields (like close price for SMA),
        you can provide just those parameters and accept defaults for others.
        """
        # ✅ Good: Minimal parameters for SMA testing
        bar = TestDataStubs.bar_5decimal(
            instrument_id=TestIdStubs.btcusdt_binance_id(), close=50000.0
        )

        # Bar has sensible defaults for other fields
        assert bar.close.as_double() == 50000.0
        assert bar.open is not None  # Has default value
        assert bar.high is not None
        assert bar.low is not None

    def test_using_test_id_stubs(self):
        """Use TestIdStubs for creating test identifiers.

        TestIdStubs provides pre-configured identifiers for common instruments
        and venues. This ensures identifier format matches Nautilus expectations.
        """
        # ✅ Good: Use TestIdStubs for identifiers
        btc_id = TestIdStubs.btcusdt_binance_id()
        eth_id = TestIdStubs.ethusdt_binance_id()

        # Verify identifier properties
        assert btc_id.symbol.value == "BTCUSDT"
        assert btc_id.venue.value == "BINANCE"

        assert eth_id.symbol.value == "ETHUSDT"
        assert eth_id.venue.value == "BINANCE"

    def test_using_test_event_stubs(self):
        """Use TestEventStubs for creating test events.

        TestEventStubs provides methods for creating order events, position
        events, and other trading events with realistic properties.
        """
        # ✅ Good: Use TestEventStubs for events
        order_submitted = TestEventStubs.order_submitted()
        order_accepted = TestEventStubs.order_accepted()

        # Verify event properties
        assert order_submitted is not None
        assert order_accepted is not None

        # Events have proper Nautilus structure
        assert hasattr(order_submitted, "event_id")
        assert hasattr(order_accepted, "event_id")

    def test_combining_test_stubs_for_realistic_scenarios(self):
        """Combine multiple TestStubs to create realistic test scenarios.

        This example shows how to use TestInstrumentProvider and TestDataStubs
        together to create a complete market data scenario.
        """
        # Create instrument
        instrument = TestInstrumentProvider.btcusdt_binance()

        # Create sequence of bars for the instrument
        bars = []
        prices = [50000.0, 50500.0, 51000.0, 51500.0, 52000.0]

        for price in prices:
            bar = TestDataStubs.bar_5decimal(
                instrument_id=instrument.id, close=price
            )
            bars.append(bar)

        # Verify we have a realistic test scenario
        assert len(bars) == len(prices)
        assert bars[0].close.as_double() == 50000.0
        assert bars[-1].close.as_double() == 52000.0
        assert all(bar.instrument_id == instrument.id for bar in bars)

    def test_test_stubs_provide_consistent_data(self):
        """Verify that TestStubs provide consistent, reproducible data.

        When called with the same parameters, TestStubs should return
        consistent data structures. This is important for test reliability.
        """
        # Create two bars with same parameters
        bar1 = TestDataStubs.bar_5decimal(
            instrument_id=TestIdStubs.btcusdt_binance_id(), close=50000.0
        )

        bar2 = TestDataStubs.bar_5decimal(
            instrument_id=TestIdStubs.btcusdt_binance_id(), close=50000.0
        )

        # Both bars should have same structure
        assert bar1.instrument_id == bar2.instrument_id
        assert bar1.close.as_double() == bar2.close.as_double()

    def test_test_stubs_use_realistic_precision(self):
        """Verify that TestStubs use realistic price precision.

        Different markets have different precision requirements:
        - Crypto: Often 5-8 decimals
        - FX: Often 5 decimals
        - Stocks: Often 2 decimals

        TestDataStubs.bar_5decimal() ensures appropriate precision.
        """
        # Create bar with 5 decimal precision
        bar = TestDataStubs.bar_5decimal(
            instrument_id=TestIdStubs.btcusdt_binance_id(), close=50000.12345
        )

        # Verify precision is maintained
        close_price = bar.close.as_double()
        assert close_price == 50000.12345

        # Price is represented with proper decimal handling
        assert isinstance(bar.close.as_double(), float)


@pytest.mark.integration
class TestNautilusStubsAntiPatterns:
    """Examples of what NOT to do when using Nautilus TestStubs.

    These examples show common mistakes and why to avoid them.
    """

    def test_dont_manually_create_instruments(self):
        """❌ BAD: Don't manually create instruments when TestInstrumentProvider exists.

        Manual instrument creation is error-prone and may not match real
        exchange specifications. Always use TestInstrumentProvider.
        """
        # ❌ Bad: Manual instrument creation
        # from nautilus_trader.model.identifiers import InstrumentId
        # from nautilus_trader.model.instruments import CryptoFuture
        # ...complex manual setup...

        # ✅ Good: Use TestInstrumentProvider
        btc = TestInstrumentProvider.btcusdt_binance()
        assert btc.id.symbol.value == "BTCUSDT"

    def test_dont_hardcode_instrument_ids(self):
        """❌ BAD: Don't hardcode instrument ID strings.

        Hardcoded strings may not match Nautilus ID format expectations.
        Always use TestIdStubs for consistent ID formatting.
        """
        # ❌ Bad: Hardcoded ID string
        # instrument_id = "BTCUSDT.BINANCE"  # Wrong format

        # ✅ Good: Use TestIdStubs
        instrument_id = TestIdStubs.btcusdt_binance_id()
        assert instrument_id.symbol.value == "BTCUSDT"
        assert instrument_id.venue.value == "BINANCE"

    def test_use_test_stubs_consistently(self):
        """✅ GOOD: Use TestStubs consistently throughout your test suite.

        Consistency makes tests easier to understand and maintain.
        If everyone uses the same TestStubs patterns, tests are predictable.
        """
        # Consistent pattern across all integration tests
        instrument = TestInstrumentProvider.btcusdt_binance()
        bar = TestDataStubs.bar_5decimal(
            instrument_id=instrument.id, close=50000.0
        )

        assert bar.instrument_id == instrument.id
